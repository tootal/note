# 图论
## 树上启发式合并（dsu on tree）
基本原理：暴力枚举答案时，最后一个子树的答案不用清空，因此可以最后枚举重子树的答案。

### [CF600E](https://codeforces.com/problemset/problem/600/E)
题意：n个节点的一棵树，1为根节点，每个节点有一个颜色1~n，若一种颜色在子树的出现次数最多，则称这种颜色掌控了这棵子树，求每个子树的掌控颜色之和。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<int> c(n+1);
    for (int i = 1; i <= n; i++) cin >> c[i];
    struct Node {
        vector<int> son;
        // fa记录父节点编号，size记录子树大小
        // hson记录重子节点编号
        // L记录子树起始dfs序，R记录终止dfs序
        int fa, size, hson, L, R;
    };
    vector<Node> G(n+1);
    for (int i = 1; i < n; i++) {
        int u, v; cin >> u >> v;
        G[u].son.push_back(v);
        G[v].son.push_back(u);
    }
    vector<int> dfn{0}; // dfn[i]记录dfs序为i的节点编号
    function<void(int)> dfs=[&](int u) {
        G[u].L = (int)dfn.size();
        dfn.push_back(u);
        G[u].size = 1;
        int hson = 0;
        for (auto v : G[u].son) {
            if (v == G[u].fa) continue;
            G[v].fa = u;
            dfs(v);
            G[u].size += G[v].size;
            if (G[v].size > G[hson].size) hson = v;
        }
        G[u].hson = hson;
        G[u].R = (int)dfn.size()-1;
    };
    dfs(1);
    vector<int> Max(n+1); // 表示子树i中出现最多的颜色次数
    vector<long long> Ans(n+1); // 表示子树i中出现最多的颜色和
    vector<int> Num(n+1); // 统计颜色i出现次数（共用）
    function<void(int, bool)> sol=[&](int u, bool is_hson) {
        int hson = G[u].hson, fa = G[u].fa;
        for (auto v : G[u].son) {
            if (v == hson || v == fa) continue;
            sol(v, false); // 先处理所有轻儿子
        }
        if (hson != 0) sol(hson, true); // 再处理重儿子
        Ans[u] = Ans[hson], Max[u] = Max[hson]; // 利用重儿子的答案更新当前节点的答案
        auto update_ans=[&](int col) {
            Num[col]++;
            if (Num[col] > Max[u]) Max[u] = Num[col], Ans[u] = col;
            else if (Num[col] == Max[u]) Ans[u] += col;
        };
        for (auto v : G[u].son) { // 重新计算所有轻儿子的答案
            if (v == hson || v == fa) continue;
            // 利用dfs序范围遍历子树
            for (int j = G[v].L; j <= G[v].R; j++) update_ans(c[dfn[j]]);
        }
        update_ans(c[u]); // 统计当前节点的答案
        // 消除计算轻儿子答案时产生的数据
        if (!is_hson) for (int j = G[u].L; j <= G[u].R; j++) Num[c[dfn[j]]] = 0;
    };
    sol(1, false);
    for (int i = 1; i <= n; i++) cout << Ans[i] << ' ';
    cout << '\n';
    return 0;
}
```