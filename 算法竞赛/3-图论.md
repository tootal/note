# 图论
## Dijkstra算法
[CF20C](https://codeforces.com/contest/20/problem/C)

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    ios::sync_with_stdio(false), cin.tie(0);
    int n, m;
    cin >> n >> m;
    vector<vector<pair<int, int>>> G(n);
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        u--, v--;
        G[u].emplace_back(v, w);
        G[v].emplace_back(u, w);
    }
    vector<long long> dis(n, 1e18);
    vector<int> pre(n, -1);
    priority_queue<pair<long long, int>> Q;
    dis[0] = 0;
    Q.emplace(0, 0);
    while (!Q.empty()) {
        auto [d, u] = Q.top();
        d = -d; // 优先队列中保存的是距离的负值
        Q.pop();
        if (u == n-1) break; // 已经找到终点
        if (d != dis[u]) continue; // 重复入队的点
        for (auto [v, w] : G[u]) {
            if (d + w < dis[v]) {
                dis[v] = d + w;
                pre[v] = u;
                Q.emplace(-(d+w), v);
            }
        }
    }
    if (~pre.back()) { // 打印路径
        vector<int> path{n-1};
        for (int u = n-1; u; u = pre[u]) {
            path.push_back(pre[u]);
        }
        reverse(path.begin(), path.end());
        for (auto p : path) cout << p+1 << ' ';
        cout << '\n';
    } else cout << -1 << '\n';
    return 0;
}
```

## Tarjan算法

### 求强连通分量
![](_v_images/20201203151215813_18397.png)

注意：强连通分量是**有向图**中的概念，无向图中求连通分量不需要Tarjan算法，直接dfs或者并查集即可。
原理：如果结点u是某个强连通分量在搜索树中遇到的第一个结点，那么这个强连通分量的其余结点肯定是在搜索树中以u为根的子树中。u被称为这个强连通分量的根。

[Luogu P2341](https://www.luogu.com.cn/problem/P2341)
关键思路：对于一个有向无环图来说，其中有且仅有一个点出度为零，那么这个特殊的点，可以由其他任何点到达。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> G(n);
    while (m--) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        G[u].push_back(v);
    }
    int cnt = 0, scc = 0; // cnt为当前dfs序，scc为强连通分量个数
    // dfn记录dfs序，low记录回溯值，belong记录所属的强连通分量
    vector<int> dfn(n), low(n), belong(n);
    stack<int> st; // 记录之前搜索过的节点
    vector<bool> inst(n); // 判断节点是否在栈中
    function<void(int)> dfs=[&](int u) {
        dfn[u] = low[u] = ++cnt;
        st.push(u);
        inst[u] = true;
        for (auto v : G[u]) {
            if (!dfn[v]) { // 如果没有访问过
                dfs(v); // 先访问子节点
                low[u] = min(low[u], low[v]); // 再更新回溯值
            } else if (inst[v]) { // 如果v被访问过并在栈中
                // 这里不能用low[v]去更新，因为以v为根的子树还没有遍历完
                low[u] = min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) { // 强连通分量的树根
            // 栈中u上面的节点构成一个强连通分量
            int v;
            do {
                v = st.top(); st.pop(); inst[v] = false;
                belong[v] = scc;
            } while (v != u);
            scc++;
        }
    };
    for (int i = 0; i < n; i++) {
        if (!dfn[i]) dfs(i);
    }
    // 缩点后的图的出度outd以及每个点代表的实际点数val
    vector<int> out(scc), val(scc);
    for (int i = 0; i < n; i++) {
        int u = belong[i];
        val[u]++;
        for (auto j : G[i]) {
            int v = belong[j];
            if (u != v) out[u]++;
        }
    }
    int out0 = 0, outi; // 出度为0的点的个数及其下标
    for (int i = 0; i < scc; i++) {
        if (out[i] == 0) {
            outi = i;
            out0++;
        }
    }
    if (out0 == 1) cout << val[outi] << '\n';
    else cout << "0\n";
    return 0;
}
```

### 求割点
注意：求连通分量的Tarjan算法与求割点的Tarjan算法类似但不完全相同。

![](_v_images/20201203152511316_5349.png)

基本原理：当u为非根节点，`low[v]>=dfn[u]`时，u为割点。

[Luogu 3388](https://www.luogu.com.cn/problem/P3388)

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int main() {
    int n, m; cin >> n >> m;
    vector<vector<int>> G(n);
    for (int i = 0; i < m; i++) {
        int u, v; cin >> u >> v;
        u--, v--;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    int cnt = 0;
    // dfn记录dfs序,low表示追溯值
    // (即以当前结点为根搜索时能访问的最小dfn值,不通过父节点)
    vector<int> dfn(n), low(n);
    // cut表示节点是否为割点
    vector<bool> cut(n);
    function<void(int, bool)> dfs = [&](int u, bool is_root) {
        dfn[u] = low[u] = ++cnt;
        int children = 0;
        for (auto v : G[u])
            // 判断v是否访问过
            if (dfn[v]) low[u] = min(low[u], dfn[v]); 
            else {
                dfs(v, false);
                low[u] = min(low[u], low[v]); // 更新追溯值
                if (dfn[u] <= low[v]) {
                    cut[u] = true;
                    children++; // 统计子树个数
                }
            }
        // 对于根节点,如果有2棵及以上子树就为割点,否则不是
        if (is_root && children == 1) cut[u] = false;
    };
    for (int i = 0; i < n; i++) if (!dfn[i]) dfs(i, true);
    vector<int> ans;
    for (int i = 0; i < n; i++) if (cut[i]) ans.push_back(i);
    cout << ans.size() << '\n'; 
    for (auto a : ans) cout << (a+1) << ' '; cout << '\n';
    return 0;
}
```

### 求桥
原理：对于一条边u->v，如果low[v]<=dfn[u]，说明v可以不通过u的情况下访问到u本身或其祖先结点，那么u->v显然就不是桥。反之low[v]>dfn[u]，说明u->v是桥。

HDU4738，题意：求桥的最小权值，有一些特殊情况。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
bool solve() {
    int n, m;
    cin >> n >> m;
    if (n == 0 && m == 0) return false;
    vector<vector<pair<int, int>>> G(n);
    const int INF = 1e5;
    auto add_edge = [&](int u, int v, int w) {
        // 重边处理,把重复边赋值为INF
        for (auto &e : G[u]) {
            if (e.first == v) {
                e.second = INF;
                return ;
            }
        }
        G[u].emplace_back(v, w);
    };
    for (int i = 0; i < m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--, v--;
        add_edge(u, v, w);
        add_edge(v, u, w);
    }
    int cnt = 0, ans = INF;
    vector<int> dfn(n), low(n);
    function<void(int, int)> dfs = [&](int u, int fa) {
        dfn[u] = low[u] = ++cnt;
        for (auto e : G[u]) {
            int v = e.first, w = e.second;
            if (!dfn[v]) {
                dfs(v, u);
                low[u] = min(low[u], low[v]);
                if (low[v] > dfn[u]) { // u->v为桥
                    ans = min(ans, w);
                }
            } else if (v != fa) {
                low[u] = min(low[u], dfn[v]);
            }
        }
    };
    int cc = 0; // 连通分量数
    for (int i = 0; i < n; i++) {
        if (!dfn[i]) {
            cc++;
            dfs(i, -1);
        }
    }
    int res = ans;
    if (cc > 1) res = 0; // 已经完成目标
    else if (ans == INF) res = -1; // 重边不可能为桥
    else if (ans == 0) res = 1; // 即使边权为0也需要派1人(考虑实际意义)
    cout << res << '\n';
    return true;
}
int main() {
    while (solve()) ;
    return 0;
}
```

## 树上启发式合并（dsu on tree）
用于解决需要**对每个子树进行统计答案**的问题。
基本原理：暴力枚举答案时，最后一个子树的答案不用清空，因此可以最后枚举重子树的答案。
小技巧：第一遍dfs时记录子树的dfs序范围，后面可以利用dfs序**用循环遍历子树**。

[CF600E](https://codeforces.com/problemset/problem/600/E)
题意：n个节点的一棵树，1为根节点，每个节点有一个颜色1~n，若一种颜色在子树的出现次数最多，则称这种颜色掌控了这棵子树，求每个子树的掌控颜色之和。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<int> c(n+1);
    for (int i = 1; i <= n; i++) cin >> c[i];
    struct Node {
        vector<int> son;
        // fa记录父节点编号，size记录子树大小
        // hson记录重子节点编号
        // L记录子树起始dfs序，R记录终止dfs序
        int fa, size, hson, L, R;
    };
    vector<Node> G(n+1);
    for (int i = 1; i < n; i++) {
        int u, v; cin >> u >> v;
        G[u].son.push_back(v);
        G[v].son.push_back(u);
    }
    vector<int> dfn{0}; // dfn[i]记录dfs序为i的节点编号
    function<void(int)> dfs=[&](int u) {
        G[u].L = (int)dfn.size();
        dfn.push_back(u);
        G[u].size = 1;
        int hson = 0;
        for (auto v : G[u].son) {
            if (v == G[u].fa) continue;
            G[v].fa = u;
            dfs(v);
            G[u].size += G[v].size;
            if (G[v].size > G[hson].size) hson = v;
        }
        G[u].hson = hson;
        G[u].R = (int)dfn.size()-1;
    };
    dfs(1);
    vector<int> Max(n+1); // 表示子树i中出现最多的颜色次数
    vector<long long> Ans(n+1); // 表示子树i中出现最多的颜色和
    vector<int> Num(n+1); // 统计颜色i出现次数（共用）
    function<void(int, bool)> sol=[&](int u, bool is_hson) {
        int hson = G[u].hson, fa = G[u].fa;
        for (auto v : G[u].son) {
            if (v == hson || v == fa) continue;
            sol(v, false); // 先处理所有轻儿子
        }
        if (hson != 0) sol(hson, true); // 再处理重儿子
        Ans[u] = Ans[hson], Max[u] = Max[hson]; // 利用重儿子的答案更新当前节点的答案
        auto update_ans=[&](int col) {
            Num[col]++;
            if (Num[col] > Max[u]) Max[u] = Num[col], Ans[u] = col;
            else if (Num[col] == Max[u]) Ans[u] += col;
        };
        for (auto v : G[u].son) { // 重新计算所有轻儿子的答案
            if (v == hson || v == fa) continue;
            // 利用dfs序范围遍历子树
            for (int j = G[v].L; j <= G[v].R; j++) update_ans(c[dfn[j]]);
        }
        update_ans(c[u]); // 统计当前节点的答案
        // 消除计算轻儿子答案时产生的数据
        if (!is_hson) for (int j = G[u].L; j <= G[u].R; j++) Num[c[dfn[j]]] = 0;
    };
    sol(1, false);
    for (int i = 1; i <= n; i++) cout << Ans[i] << ' ';
    cout << '\n';
    return 0;
}
```

