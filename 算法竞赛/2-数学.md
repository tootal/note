# 数学
## 快速幂
同时适用于小范围幂次，使用时注意两个参数**都为`long long`**，方便识别重载。

```cpp
// 快速幂
ll pow(ll x, ll y, ll mod = 9e18, ll ans = 1) { 
    if (!y) return ans;
    if (y&1) return pow(x, y-1, mod, ans*x%mod);
    else return pow(x*x%mod, y>>1, mod, ans);
}
```

## 逆元
### 费马小定理

```cpp
ll inv(ll x, ll mod) { return qpow(x, mod-2, mod); }
```

## 欧几里得算法
### 最大公因数
最好使用自带的`__gcd`，自C++17起，`<numeric>`中自带了`gcd`与`lcm`函数。

```cpp
ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }
ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }
```

## 数论分块


常见问题：求$\sum\limits_{i = 1}^n \lfloor\frac{n}{i}\rfloor$。

以n=12为例，上式变成12+6+4+3+2+2+1+1+1+1+1+1。可以发现上面的数会分成若干块，每一块的值相同。

可以通过如下方式枚举每一块。注意，有时候循环范围的`n`与循环体里的`n`可能不是同一个变量，这时注意判断**除数是否可能为0**！

```cpp
for (int l = 1, r; l <= n; l = r + 1) {
    r = n / (n / l);
    // do something
}
```

每一块的范围是$[l, r]$， 值均为$n / l$。

### 多个变量
有多个变量需要分块时，例如$\sum\limits_{i = 1}^n\sum\limits_{j=1}^m \lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor$，就需要把块分得再细一点，保证每个块中的每个变量取值都是相同的（不是变量间相同，而是随着变量的增长取值不变）。

```cpp
int ans = 0; // 分块
for (int l = 1, r; l <= min(n, m); l = r + 1) {
    r = min(n / (n / l), m / (m / l));
    // do something
}
```

### 变换
数论分块更多的是一种思想，变化非常多。

例如：[Luogu P2261 CQOI2007余数求和](https://www.luogu.com.cn/problem/P2261)

需要作如下转换。

\begin{align*}
G(n, k) 
&= \sum_{i = 1} ^ {n} k \ \ mod \ \ i \\
&= \sum_{i = 1} ^ {n} k - \left \lfloor \frac{k}{i} \right \rfloor * i \\
&= nk - \sum_{i = 1} ^ {n} \left \lfloor \frac{k}{i} \right \rfloor * i
\end{align*}

## 素数
### 埃拉托斯特尼筛法
虽然理论复杂度不及线性筛，但实际上跑得飞快。

```cpp
#include <bits/stdc++.h>
using namespace std;
// 埃氏筛法，预处理出小于n的所有素数
// 时间复杂度O(nloglogn)，空间复杂度O(n)
typedef long long ll;
int main() {
    ll n = 1e8;
    // cin >> n;
    vector<bool> is_prime(n, true);
    is_prime[0] = is_prime[1] = false;
    vector<ll> prime;
    for (ll i = 2; i < n; i++) {
        if (!is_prime[i]) continue;
        prime.push_back(i);
        for (ll j = i * i; j < n; j += i) is_prime[j] = false;
    }
    // cout << prime.size() << '\n';
    // for (auto p : prime) { cout << p << ' '; } cout << '\n';
    cerr << "Time: " << clock() << " ms \n";
    return 0;
}
// 运行结果：
// Time: 623 ms
```

一些常用的优化，如只筛奇数。

```cpp
#include <bits/stdc++.h>
using namespace std;
// 埃氏筛法，预处理出小于n的所有素数
// 时间复杂度O(nloglogn)，空间复杂度O(n)
typedef long long ll;
int main() {
    ll n = 1e8;
    // cin >> n;
    vector<bool> is_prime(n, true);
    is_prime[0] = is_prime[1] = false;
    vector<ll> prime{2};
    for (ll j = 4; j < n; j += 2) is_prime[j] = false;
    for (ll i = 3; i < n; i += 2) {
        if (!is_prime[i]) continue;
        prime.push_back(i);
        for (ll j = i * i; j < n; j += i) is_prime[j] = false;
    }
    // cout << prime.size() << '\n';
    // for (auto p : prime) { cout << p << ' '; } cout << '\n';
    cerr << "Time: " << clock() << " ms \n";
    return 0;
}
// 运行结果：
// Time: 547 ms
```

### 欧拉筛法（线性筛）
优势在于可以同时筛出其他的积性函数。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
// 欧拉筛法（线性筛），预处理出小于n的所有素数
// 时间复杂度O(n)
int main() {
    ll n = 1e8;
    // cin >> n;
    vector<bool> is_prime(n, true);
    is_prime[0] = is_prime[1] = false;
    vector<ll> prime;
    if (n > 4) is_prime[4] = false;
    for (ll i = 3; i < n; i += 2) {
        if (!is_prime[i]) continue;
        prime.push_back(i);
        for (auto p : prime) {
            if (i * p >= n) break;
            is_prime[i * p] = false;
            if (i % p == 0) break;
        }
    }
    // for (auto p : prime) { cout << p << ' '; } cout << '\n';
    cerr << "Time: " << clock() << " ms\n";
    return 0;
}
// 运行结果：
// Time: 847 ms
```

### 质因数分解
返回一个`vector<pair<ll, ll>`，`first`为质数，`second`为幂次。

```cpp
// 质因数分解
vector<pair<ll, ll>> get_factor(ll n) {
    vector<pair<ll, ll>> factor;
    for (auto p : prime) {
        if (p > n / p) break;
        if (n % p) continue;
        int cnt = 0;
        while (n % p == 0) cnt++, n /= p;
        factor.emplace_back(p, cnt);
    }
    if (n > 1) factor.emplace_back(n, 1);
    return factor;
}
```

### 枚举因子
返回n的所有因子。

```cpp
// 枚举因子
vector<ll> perm_factor(ll n) {
    auto factor = get_factor(n);
    vector<ll> divisor;
    function<void(ll, int)> dfs = [&](ll d, int i) {
        if (i == (int)factor.size()) return divisor.push_back(d);
        for (ll j = 0; j <= factor[i].second; j++)
            dfs(d * pow(factor[i].first, j), i+1);
    };
    return dfs(1, 0), divisor;
}
```

## 二次剩余

```cpp
// 判断n是否为p的二次剩余
bool is_quad(ll n, ll p) { 
    return pow(n, (p-1)>>1, p) == 1;
}
```

## 筛法

### 筛法求欧拉函数

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
// 筛法求欧拉函数，预处理出小于n的欧拉函数值
int main() {
    ll n = 1e7;
    // cin >> n;
    vector<int> phi(n);
    phi[1] = 1;
    for (int i = 2; i < n; i++) if (!phi[i]) {
        for (int j = i; j < n; j += i) {
            if (!phi[j]) phi[j] = j;
            phi[j] = phi[j] / i * (i - 1);
        }
    }
    // for (int i = 1; i < n; i++) { cout << phi[i] << ' '; } cout << '\n';
    cerr << "Time: " << clock() << " ms\n";
    return 0;
}
// 运行结果：
// Time: 302 ms
```

### 筛法求莫比乌斯函数

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
// 筛法求莫比乌斯函数，预处理出小于n的莫比乌斯函数值
// 同时筛出质数
// 时间复杂度O(n)
int main() {
    ll n = 1e8;
    // cin >> n;
    vector<int> mu(n), prime;
    vector<bool> is_prime(n, true);
    is_prime[0] = is_prime[1] = false;
    mu[1] = 1;
    for (int i = 2; i < n; i++) {
        if (is_prime[i]) mu[i] = -1, prime.push_back(i);
        for (auto p : prime) {
            if (i * p >= n) break;
            is_prime[i * p] = false;
            if (i % p == 0) {
                mu[i * p] = 0;
                break;
            }
            mu[i * p] = -mu[i];
        }
    }
    // for (int i = 1; i < n; i++) { cout << mu[i] << ' '; } cout << '\n';
    cerr << "Time: " << clock() << " ms\n";
    return 0;
}
// 运行结果：
// Time: 854 ms
```

## 莫比乌斯反演
### 统计GCD
[Luogu P2522 【HAOI2011】Problem b](https://www.luogu.com.cn/problem/P2522)
求：

$$
\sum_{x=a}^b\sum_{y=c}^d [gcd(x, y)=k]
$$

利用容斥转换为：

$$
\sum_{i=1}^n\sum_{j=1}^m [gcd(i, j)=1]
$$

根据单位函数$\epsilon=\mu * 1$，其中$*$为迪利克雷卷积，展开可得：

$$
\sum_{i=1}^n\sum_{j=1}^m \sum_{d|gcd(i, j)} \mu(d)=\sum_{i=1}^n\sum_{j=1}^m \sum_{d=1} [d|i][d|j]\mu(d)
$$

变换求值顺序可得：

$$
\sum_{d=1}\mu(d)\sum_{i=1}^n [d|i] \sum_{j=1}^m  [d|j]=\sum_{d=1}\mu(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor
$$

数论分块可做，复杂度$O(n+n\sqrt{n})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ALL(x) (x).begin(), (x).end()
const int N = 5e4 + 5;
vector<int> prime, mu(N); // mu保存莫比乌斯函数前缀和
vector<bool> is_prime(N, true);
void get_mu() { // 线性筛法
    mu[1] = 1;
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i < N; i++) {
        if (is_prime[i]) {
            mu[i] = -1;
            prime.push_back(i);
        }
        for (auto p : prime) {
            if (i * p >= N) break;
            is_prime[i * p] = false;
            if (i % p == 0) {
                mu[i * p] = 0; // 含p^2
                break;
            }
            mu[i * p] = -mu[i]; // 本质不同的素因子个数+1
        }
    }
    partial_sum(ALL(mu), mu.begin()); // 求前缀和
}
int solve(int n, int m) {
    int ans = 0; // 分块
    for (int l = 1, r; l <= min(n, m); l = r + 1) {
        r = min(n / (n / l), m / (m / l));
        ans += (mu[r]-mu[l-1]) * (n / l) * (m / l);
    }
    return ans;
}
int main() {
    get_mu();
    int n; cin >> n;
    while (n--) {
        int a, b, c, d, k;
        cin >> a >> b >> c >> d >> k;
        a--, c--; a /= k, b /= k, c /= k, d /= k;
        cout << solve(b, d) - solve(b, c) - solve(a, d) + solve(a, c) << '\n';
    }
    return 0;
}
```

### 容斥求LCM
[「SPOJ 5971」LCMSUM](https://www.spoj.com/problems/LCMSUM/)

求：

$$
\sum_{i=1}^n lcm(i, n)
$$

可化简成：

$$
\frac{n}{2}(\sum_{d|n} d \cdot \varphi(d) + 1)
$$

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e6 + 5;
vector<ll> prime, g(N);
vector<bool> is_prime(N, true);
void get_g() { // 线性筛法
    g[1] = 1;
    is_prime[0] = is_prime[1] = false;
    for (ll i = 2; i < N; i++) {
        if (is_prime[i]) {
            g[i] = i * (i - 1) + 1;
            prime.push_back(i);
        }
        for (auto p : prime) {
            if (i * p >= N) break;
            is_prime[i * p] = false;
            if (i % p == 0) {
                g[i * p] = g[i] + (g[i] - g[i / p]) * p * p;
                break;
            }
            g[i * p] = g[i] * g[p];
        }
    }
}
int main() {
    get_g();
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        cout << (g[n] + 1) * n / 2 << '\n';
    }
    return 0;
}
```