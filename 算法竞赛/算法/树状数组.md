# 树状数组
## 相关博客  
[树状数组详解](https://www.cnblogs.com/xenny/p/9739600.html)  

## 写在前面
树状数组能做的，线段树都能做，但代码量大很多。

## 动态连续和查询问题
给定$\{a_n\}$，支持两种操作：修改单个元素（$a_x=a_x+d$），求一段区间和（$a_l+a_{l+1}+\dots+a_r$）。  

[敌兵布阵](http://acm.hdu.edu.cn/showproblem.php?pid=1166)  

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int n,a[N];
int lowbit(int x){
	return x&-x;
}
void update(int x,int v){
	while(x<=n){
		a[x]+=v;
		x+=lowbit(x);
	}
}
int query(int x){
	int s=0;
	while(x>0){
		s+=a[x];
		x-=lowbit(x);
	}
	return s;
}
int main(){
	int T;
	scanf("%d",&T);
	for(int t=1;t<=T;t++){
		memset(a,0,sizeof(a));
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			int v;
			scanf("%d",&v);
			update(i,v);
		}
		printf("Case %d:\n",t);
		while(true){
			char op[8];
			int x,y;
			scanf(" %s",op);
			if(op[0]=='E')break;
			scanf("%d%d",&x,&y);
			if(op[0]=='Q')printf("%d\n",query(y)-query(x-1));
			if(op[0]=='A')update(x,y);
			if(op[0]=='S')update(x,-y);
		}
	}
	return 0;
}
```

## 权值树状数组
树状数组的一个经典应用。  已知$\{a_n\}$，设$c_i=k$表示$i$在$\{a_n\}$中出现了$k$次。（$\{a_n\}$可能要离散化）  
依次插入$\{a_n\}$（更新$c_i$）。则$c_{a_i}$的前缀和即表示$a_i$前面小于$a_i$的数的个数。用树状数组维护即可。  
用此方法同样可以求逆序对。  

[Ping pong](https://vjudge.net/problem/UVALive-4329)  
注意树状数组的大小！  

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e4+5;
const int M=1e5+5;
int n,m,a[N],b[M],c[N],d;
int lowbit(int x){
	return x&-x;
}
void update(int x){
	while(x<M){
		b[x]++;
		x+=lowbit(x);
	}
}
int query(int x){
	int s=0;
	while(x>0){
		s+=b[x];
		x-=lowbit(x);
	}
	return s;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		memset(b,0,sizeof(b));
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			c[i]=query(a[i]-1);
			update(a[i]);
		}
		memset(b,0,sizeof(b));
		long long ans=0;
		for(int i=n;i>=1;i--){
			d=query(a[i]-1);
			update(a[i]);
			// printf("c[%d]=%d,d=%d\n",i,c[i],d);
			ans+=1ll*c[i]*(n-i-d)+1ll*d*(i-1-c[i]);
		}
		printf("%lld\n",ans);
	}
	return 0;
}

```  

[Ultra-QuickSort](https://vjudge.net/problem/POJ-2299)  
求逆序对数。需要离散化。  
```cpp
// #include <bits/stdc++.h>
#include <utility>
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
typedef pair<int,int> pii;
const int N=5e5+5;
int n,v,b[N];
pii a[N];
int lowbit(int x){
	return x&-x;
}
void update(int x){
	while(x<N){
		b[x]++;
		x+=lowbit(x);
	}
}
int query(int x){
	int s=0;
	while(x>0){
		s+=b[x];
		x-=lowbit(x);
	}
	return s;
}
int main(){
	while(~scanf("%d",&n)&&n){
		for(int i=1;i<=n;i++){
			scanf("%d",&v);
			a[i]=pii(v,i);
		}
		sort(a+1,a+1+n);
		long long ans=0;
		memset(b,0,sizeof(b));
		for(int i=1;i<=n;i++){
			ans+=i-1-query(a[i].second-1);
			update(a[i].second);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```