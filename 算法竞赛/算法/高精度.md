# 高精度
## 正整数加法
[洛谷P1601 A+B Problem（高精）](https://www.luogu.com.cn/problem/P1601)

### Python3
总之就是优先考虑Python。
```py
print(int(input()) + int(input()))
```


### Java
如果熟悉Java的话，BigInteger也是一个不错的选择。

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.math.BigInteger;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BigInteger a = new BigInteger(in.readLine());
        BigInteger b = new BigInteger(in.readLine());
        System.out.println(a.add(b));
    }
}
```

### C++
一般来说，像这种比较简单的，可以当成模拟题来做，没必要套板子。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef vector<char> bigint;
void operator+=(bigint &x, bigint &y) {
    x.resize(max(x.size(), y.size()) + 1, '0');
    for (int i = 0; i < y.size(); i++) {
        x[i] += y[i] - '0';
        x[i + 1] += (x[i] - '0') / 10;
        x[i] = (x[i] - '0') % 10 + '0';
    }
    if (x.back() == '0') x.pop_back();
}
int main() {
    string sa, sb;
    cin >> sa >> sb;
    bigint a(sa.rbegin(), sa.rend());
    bigint b(sb.rbegin(), sb.rend());
    a += b;
    cout << string(a.rbegin(), a.rend()) << '\n';
    return 0;
}
```

当然整理一个模板也是可以的。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct bigint : vector<int> {
    const int WIDTH = 8, BASE = pow(10, WIDTH);
};

bigint operator+(const bigint &x, const bigint &y) {
    bigint ans(x);
    ans.resize(max(x.size(), y.size()) + 1, 0);
    for (int i = 0; i < y.size(); i++) {
        ans[i] += y[i];
        ans[i + 1] += ans[i] / ans.BASE;
        ans[i] %= ans.BASE;
    }
    if (ans.back() == 0) ans.pop_back();
    return ans;
}

istream& operator>>(istream &in, bigint &x) {
    string s;
    cin >> s;
    int n = s.length(), i;
    x.clear();
    for (i = n - x.WIDTH; i >= 0; i -= x.WIDTH) {
        int t = 0;
        for (int j = 0; j < x.WIDTH; j++) t = t * 10 + s[i + j] - '0';
        x.push_back(t);
    }
    int t = 0;
    for (int j = 0; j < i + x.WIDTH; j++) t = t * 10 + s[j] - '0';
    if (x.empty() || t != 0) x.push_back(t);
    return in;
}
ostream& operator<<(ostream &out, const bigint &x) {
    out << x.back();
    for (int i = x.size() - 2; i >= 0; i--)
        out << setw(x.WIDTH) << setfill('0') << x[i];
    return out;
}
int main() {
    bigint a, b;
    cin >> a >> b;
    cout << (a + b) << '\n';
    return 0;
}
```


## 正整数乘法
[洛谷P1303 A*B Problem](https://www.luogu.com.cn/problem/P1303)

### Python3

```py
print(int(input()) * int(input()))
```

### Java

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.math.BigInteger;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BigInteger a = new BigInteger(in.readLine());
        BigInteger b = new BigInteger(in.readLine());
        System.out.println(a.multiply(b));
    }
}
```

### C++

```cpp
#include <bits/stdc++.h>
using namespace std;

struct bigint : vector<int> {
    constexpr static int WIDTH = 8, BASE = pow(10, WIDTH);
    // default is null, not zero.
    bigint() {}
    bigint(long long x) {
        do { push_back(x % BASE); x /= BASE; } while(x);
    }
    bigint(int x) : bigint((long long)x) {}
    bigint(const char *x) {
        char s[WIDTH + 1]{};
        int n = strlen(x), i = n;
        for (; i > WIDTH; i -= WIDTH)
            push_back(atol(strncpy(s, x + i - WIDTH, WIDTH)));
        push_back(atol(strncpy(s + WIDTH - i, x, i)));
    }
    bigint(const string &x) : bigint(x.c_str()) {}
    bigint& operator=(const bigint &x) {
        assign(x.begin(), x.end());
        return *this;
    }
    friend bigint operator+(const bigint &x, const bigint &y) {
        bigint ans(x);
        ans.resize(max(x.size(), y.size()) + 1, 0);
        for (int i = 0; i < y.size(); i++) {
            ans[i] += y[i];
            ans[i + 1] += ans[i] / ans.BASE;
            ans[i] %= ans.BASE;
        }
        if (ans.back() == 0) ans.pop_back();
        return ans;
    }
    friend bigint operator*(const bigint &x, const bigint &y) {
        vector<long long> res(x.size() + y.size());
        for (int i = 0; i < x.size(); i++)
            for (int j = 0; j < y.size(); j++)
                res[i + j] += 1ll * x[i] * y[j];
        bigint ans;
        for (int i = 0; i < res.size(); i++) {
            res[i + 1] += res[i] / x.BASE;
            ans.push_back(res[i] % x.BASE);
        }
        if (ans.back() == 0) ans.pop_back();
        return ans;
    }
    friend bool operator<(const bigint &x, const bigint &y) {
        return less<vector<int>>()(x, y);
    }
    friend bool operator>(const bigint &x, const bigint &y) {
        return y < x;
    }
    friend bool operator<=(const bigint &x, const bigint &y) {
        return !(y < x);
    }
    friend bool operator>=(const bigint &x, const bigint &y) {
        return !(x < y);
    }
    friend bool operator==(const bigint &x, const bigint &y) {
        return !(x < y) && !(y < x);
    }
    friend bool operator!=(const bigint &x, const bigint &y) {
        return (x < y) || (y < x);
    }
    bigint& operator+=(const bigint &x) { return *this = *this + x; }
    bigint& operator*=(const bigint &x) { return *this = *this * x; }
};
istream& operator>>(istream &in, bigint &x) {
    string s;
    cin >> s;
    x = s;
    return in;
}
ostream& operator<<(ostream &out, const bigint &x) {
    if (x.empty()) return out;
    out << x.back();
    for (int i = x.size() - 2; i >= 0; i--)
        out << setw(x.WIDTH) << setfill('0') << x[i];
    return out;
}

int main() {
    bigint a, b;
    cin >> a >> b;
    cout << a * b << '\n';
    return 0;
}
```


## 正整数加法与乘法
[P1009 阶乘之和](https://www.luogu.com.cn/problem/P1009)

### Python3

```py
from functools import reduce
print(sum([reduce(lambda x, y: x * y, range(1, i + 1)) for i in range(1, int(input()) + 1)]))
```

### Java

```cpp
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.math.BigInteger;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(in.readLine());
        BigInteger ans = BigInteger.ZERO;
        for (int i = 1; i <= n; i++) {
            BigInteger t = BigInteger.ONE;
            for (int j = 2; j <= i; j++) {
                t = t.multiply(BigInteger.valueOf(j));
            }
            ans = ans.add(t);
        }
        System.out.println(ans);
    }
}
```

### C++

```cpp
#include <bits/stdc++.h>
using namespace std;

struct bigint : vector<int> {
    constexpr static int WIDTH = 8, BASE = pow(10, WIDTH);
    // default is null, not zero.
    bigint() {}
    bigint(long long x) {
        do { push_back(x % BASE); x /= BASE; } while(x);
    }
    bigint(int x) : bigint((long long)x) {}
    bigint(const char *x) {
        char s[WIDTH + 1]{};
        int n = strlen(x), i = n;
        for (; i > WIDTH; i -= WIDTH)
            push_back(atol(strncpy(s, x + i - WIDTH, WIDTH)));
        push_back(atol(strncpy(s + WIDTH - i, x, i)));
    }
    bigint(const string &x) : bigint(x.c_str()) {}
    bigint& operator=(const bigint &x) {
        assign(x.begin(), x.end());
        return *this;
    }
    friend bigint operator+(const bigint &x, const bigint &y) {
        bigint ans(x);
        ans.resize(max(x.size(), y.size()) + 1, 0);
        for (int i = 0; i < y.size(); i++) {
            ans[i] += y[i];
            ans[i + 1] += ans[i] / ans.BASE;
            ans[i] %= ans.BASE;
        }
        if (ans.back() == 0) ans.pop_back();
        return ans;
    }
    friend bigint operator*(const bigint &x, const bigint &y) {
        vector<long long> res(x.size() + y.size());
        for (int i = 0; i < x.size(); i++)
            for (int j = 0; j < y.size(); j++)
                res[i + j] += 1ll * x[i] * y[j];
        bigint ans;
        for (int i = 0; i < res.size(); i++) {
            res[i + 1] += res[i] / x.BASE;
            ans.push_back(res[i] % x.BASE);
        }
        if (ans.back() == 0) ans.pop_back();
        return ans;
    }
    friend bool operator<(const bigint &x, const bigint &y) {
        return less<vector<int>>()(x, y);
    }
    friend bool operator>(const bigint &x, const bigint &y) {
        return y < x;
    }
    friend bool operator<=(const bigint &x, const bigint &y) {
        return !(y < x);
    }
    friend bool operator>=(const bigint &x, const bigint &y) {
        return !(x < y);
    }
    friend bool operator==(const bigint &x, const bigint &y) {
        return !(x < y) && !(y < x);
    }
    friend bool operator!=(const bigint &x, const bigint &y) {
        return (x < y) || (y < x);
    }
    bigint& operator+=(const bigint &x) { return *this = *this + x; }
    bigint& operator*=(const bigint &x) { return *this = *this * x; }
};
istream& operator>>(istream &in, bigint &x) {
    string s;
    cin >> s;
    x = s;
    return in;
}
ostream& operator<<(ostream &out, const bigint &x) {
    if (x.empty()) return out;
    out << x.back();
    for (int i = x.size() - 2; i >= 0; i--)
        out << setw(x.WIDTH) << setfill('0') << x[i];
    return out;
}

int main() {
    int n;
    cin >> n;
    vector<bigint> a(n);
    iota(a.begin(), a.end(), 1);
    partial_sum(a.begin(), a.end(), a.begin(), multiplies<bigint>());
    cout << accumulate(a.begin(), a.end(), bigint(0)) << '\n';
    return 0;
}
```

## 整数减法
[洛谷P2142 高精度减法](https://www.luogu.com.cn/problem/P2142)

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

struct bigint : deque<int> {
    typedef deque<int> container_type;
    constexpr static int WIDTH = 8, BASE = 1e8;
    bool sign = false;
    // default is null, not zero.
    bigint() {}
    bigint(long long x) {
        if (x < 0) sign = true, x = -x;
        do { push_back(x % BASE); x /= BASE; } while(x);
    }
    bigint(int x) : bigint((long long)x) {}
    bigint(const char *x) {
        if (*x == '-') x++, sign = true;
        char s[WIDTH + 1]{};
        int n = strlen(x), i = n;
        for (; i > WIDTH; i -= WIDTH)
            push_back(atol(strncpy(s, x + i - WIDTH, WIDTH)));
        push_back(atol(strncpy(s + WIDTH - i, x, i)));
    }
    bigint(const string &x) : bigint(x.c_str()) {}
    bigint& operator=(const bigint &x) {
        sign = x.sign;
        assign(x.begin(), x.end());
        return *this;
    }
    bigint operator-() const {
        bigint ans(*this);
        ans.sign = !ans.sign;
        return ans;
    }
    friend bigint operator+(const bigint &x, const bigint &y);
    friend bigint operator-(const bigint &x, const bigint &y);
    friend bigint operator*(const bigint &x, const bigint &y);
    friend bigint operator/(const bigint &x, const bigint &y);
    friend bigint operator%(const bigint &x, const bigint &y);
    bigint& operator+=(const bigint &x) { return *this = *this + x; }
    bigint& operator-=(const bigint &x) { return *this = *this - x; }
    bigint& operator*=(const bigint &x) { return *this = *this * x; }
    bigint& operator/=(const bigint &x) { return *this = *this / x; }
    bigint& operator%=(const bigint &x) { return *this = *this % x; }
    bigint& operator++() { return *this = *this + 1; }
    bigint operator++(int) { bigint ans(*this); *this = *this + 1; return ans; }
    bigint& operator--() { return *this = *this - 1; }
    bigint operator--(int) { bigint ans(*this); *this = *this - 1; return ans; }
    bool operator!() const { return empty() || size() == 1 && back() == 0; }
    operator string() const {
        if (empty()) return "";
        stringstream res;
        if (sign && !!(*this)) res << '-';
        res << back();
        for (int i = size() - 2; i >= 0; i--)
            res << setw(WIDTH) << setfill('0') << at(i);
        return res.str();
    }
};
istream& operator>>(istream &in, bigint &x) {
    string s;
    in >> s;
    x = s;
    return in;
}
ostream& operator<<(ostream &out, const bigint &x) {
    return out << (string)x;
}
bool operator==(const bigint &x, const bigint &y) {
    return !x && !y || x.sign == y.sign && equal_to<bigint::container_type>()(x, y);
}
bool operator<(const bigint &x, const bigint &y) {
    if (!x || !y) return (!!x || !!y) && (!!x && x.sign || !!y && !y.sign);
    if (x.sign != y.sign) return x.sign;
    if (x.size() != y.size()) return x.sign ^ (x.size() < y.size());
    return x.sign ^ lexicographical_compare(x.rbegin(), x.rend(), y.rbegin(), y.rend());
}
bool operator>(const bigint &x, const bigint &y) { return y < x; }
bool operator<=(const bigint &x, const bigint &y) { return !(y < x); }
bool operator>=(const bigint &x, const bigint &y) { return !(x < y); }
bool operator!=(const bigint &x, const bigint &y) { return !(x == y); }
bigint operator+(const bigint &x, const bigint &y) {
    if (x.sign) return y - (-x);
    if (y.sign) return x - (-y);
    bigint ans(x);
    ans.resize(max(x.size(), y.size()) + 1, 0);
    for (int i = 0; i < y.size(); i++) {
        ans[i] += y[i];
        ans[i + 1] += ans[i] / bigint::BASE;
        ans[i] %= bigint::BASE;
    }
    if (ans.back() == 0) ans.pop_back();
    return ans;
}
bigint operator-(const bigint &x, const bigint &y) {
    if (x.sign) return -(-x + y);
    if (y.sign) return x + (-y);
    if (x < y) return -(y - x);
    bigint ans(x);
    for (int i = 0; i < y.size(); i++) {
        if (ans[i] < y[i]) ans[i + 1]--, ans[i] += bigint::BASE;
        ans[i] -= y[i];
    }
    while (ans.size() > 1 && ans.back() == 0) ans.pop_back();
    return ans;
}
bigint operator*(const bigint &x, const bigint &y) {
    if (x == 0 || y == 0) return 0;
    vector<long long> res(x.size() + y.size());
    for (int i = 0; i < x.size(); i++)
        for (int j = 0; j < y.size(); j++)
            res[i + j] += 1ll * x[i] * y[j];
    bigint ans;
    for (int i = 0; i < res.size(); i++) {
        res[i + 1] += res[i] / bigint::BASE;
        ans.push_back(res[i] % bigint::BASE);
    }
    if (ans.back() == 0) ans.pop_back();
    ans.sign = x.sign ^ y.sign;
    return ans;
}
bigint div_helper(const bigint &x, const bigint &y, bool mod = false) {
    assert(y != 0);
    if (x == 0) return 0;
    if (x.sign) return -(-x / y);
    if (y.sign) return -(x / -y);
    bigint q, r;
    for (int i = x.size() - 1; i >= 0; i--) {
        r.push_front(x[i]);
        int lt = 0, rt = bigint::BASE;
        while (lt < rt) {
            int m = (lt + rt + 1) / 2;
            if (y * m <= r) lt = m;
            else rt = m - 1;
        }
        if (lt != 0) q.push_front(lt);
        r = r - y * lt;
    }
    if (q.empty()) q = 0;
    return mod ? r : q;
}
bigint operator/(const bigint &x, const bigint &y) { return div_helper(x, y); }
bigint operator%(const bigint &x, const bigint &y) { return div_helper(x, y, true); }


int main() {
    bigint a, b;
    cin >> a >> b;
    cout << a - b << '\n';
    return 0;
}
```
## 整数整除
[洛谷P1480 A/B Problem](https://www.luogu.com.cn/problem/P1480)

### Python3

```py
print(int(input()) // int(input()))
```

### Java
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.math.BigInteger;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BigInteger a = new BigInteger(in.readLine());
        BigInteger b = new BigInteger(in.readLine());
        System.out.println(a.divide(b));
    }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

struct bigint : deque<int> {
    typedef deque<int> container_type;
    constexpr static int WIDTH = 8, BASE = 1e8;
    bool sign = false;
    // default is null, not zero.
    bigint() {}
    bigint(long long x) {
        if (x < 0) sign = true, x = -x;
        do { push_back(x % BASE); x /= BASE; } while(x);
    }
    bigint(int x) : bigint((long long)x) {}
    bigint(const char *x) {
        if (*x == '-') x++, sign = true;
        char s[WIDTH + 1]{};
        int n = strlen(x), i = n;
        for (; i > WIDTH; i -= WIDTH)
            push_back(atol(strncpy(s, x + i - WIDTH, WIDTH)));
        push_back(atol(strncpy(s + WIDTH - i, x, i)));
    }
    bigint(const string &x) : bigint(x.c_str()) {}
    bigint& operator=(const bigint &x) {
        sign = x.sign;
        assign(x.begin(), x.end());
        return *this;
    }
    bigint operator-() const {
        bigint ans(*this);
        ans.sign = !ans.sign;
        return ans;
    }
    friend bigint operator+(const bigint &x, const bigint &y);
    friend bigint operator-(const bigint &x, const bigint &y);
    friend bigint operator*(const bigint &x, const bigint &y);
    friend bigint operator/(const bigint &x, const bigint &y);
    friend bigint operator%(const bigint &x, const bigint &y);
    bigint& operator+=(const bigint &x) { return *this = *this + x; }
    bigint& operator-=(const bigint &x) { return *this = *this - x; }
    bigint& operator*=(const bigint &x) { return *this = *this * x; }
    bigint& operator/=(const bigint &x) { return *this = *this / x; }
    bigint& operator%=(const bigint &x) { return *this = *this % x; }
    bigint& operator++() { return *this = *this + 1; }
    bigint operator++(int) { bigint ans(*this); *this = *this + 1; return ans; }
    bigint& operator--() { return *this = *this - 1; }
    bigint operator--(int) { bigint ans(*this); *this = *this - 1; return ans; }
    bool operator!() const { return empty() || size() == 1 && back() == 0; }
    operator string() const {
        if (empty()) return "";
        stringstream res;
        if (sign && !!(*this)) res << '-';
        res << back();
        for (int i = size() - 2; i >= 0; i--)
            res << setw(WIDTH) << setfill('0') << at(i);
        return res.str();
    }
};
istream& operator>>(istream &in, bigint &x) {
    string s;
    in >> s;
    x = s;
    return in;
}
ostream& operator<<(ostream &out, const bigint &x) {
    return out << (string)x;
}
bool operator==(const bigint &x, const bigint &y) {
    return !x && !y || x.sign == y.sign && equal_to<bigint::container_type>()(x, y);
}
bool operator<(const bigint &x, const bigint &y) {
    if (!x || !y) return (!!x || !!y) && (!!x && x.sign || !!y && !y.sign);
    if (x.sign != y.sign) return x.sign;
    if (x.size() != y.size()) return x.sign ^ (x.size() < y.size());
    return x.sign ^ lexicographical_compare(x.rbegin(), x.rend(), y.rbegin(), y.rend());
}
bool operator>(const bigint &x, const bigint &y) { return y < x; }
bool operator<=(const bigint &x, const bigint &y) { return !(y < x); }
bool operator>=(const bigint &x, const bigint &y) { return !(x < y); }
bool operator!=(const bigint &x, const bigint &y) { return !(x == y); }
bigint operator+(const bigint &x, const bigint &y) {
    if (x.sign) return y - (-x);
    if (y.sign) return x - (-y);
    bigint ans(x);
    ans.resize(max(x.size(), y.size()) + 1, 0);
    for (int i = 0; i < y.size(); i++) {
        ans[i] += y[i];
        ans[i + 1] += ans[i] / bigint::BASE;
        ans[i] %= bigint::BASE;
    }
    if (ans.back() == 0) ans.pop_back();
    return ans;
}
bigint operator-(const bigint &x, const bigint &y) {
    if (x.sign) return -(-x + y);
    if (y.sign) return x + (-y);
    if (x < y) return -(y - x);
    bigint ans(x);
    for (int i = 0; i < y.size(); i++) {
        if (ans[i] < y[i]) ans[i + 1]--, ans[i] += bigint::BASE;
        ans[i] -= y[i];
    }
    while (ans.size() > 1 && ans.back() == 0) ans.pop_back();
    return ans;
}
bigint operator*(const bigint &x, const bigint &y) {
    if (x == 0 || y == 0) return 0;
    vector<long long> res(x.size() + y.size());
    for (int i = 0; i < x.size(); i++)
        for (int j = 0; j < y.size(); j++)
            res[i + j] += 1ll * x[i] * y[j];
    bigint ans;
    for (int i = 0; i < res.size(); i++) {
        res[i + 1] += res[i] / bigint::BASE;
        ans.push_back(res[i] % bigint::BASE);
    }
    if (ans.back() == 0) ans.pop_back();
    ans.sign = x.sign ^ y.sign;
    return ans;
}
bigint div_helper(const bigint &x, const bigint &y, bool mod = false) {
    assert(y != 0);
    if (x == 0) return 0;
    if (x.sign) return -(-x / y);
    if (y.sign) return -(x / -y);
    bigint q, r;
    for (int i = x.size() - 1; i >= 0; i--) {
        r.push_front(x[i]);
        while (r.size() > 1 && r.back() == 0) r.pop_back();
        int lt = 0, rt = bigint::BASE;
        while (lt < rt) {
            int m = (lt + rt + 1) / 2;
            if (y * m <= r) lt = m;
            else rt = m - 1;
        }
        if (!q.empty() || lt != 0) q.push_front(lt);
        r = r - y * lt;
    }
    if (q.empty()) q = 0;
    return mod ? r : q;
}
bigint operator/(const bigint &x, const bigint &y) { return div_helper(x, y); }
bigint operator%(const bigint &x, const bigint &y) { return div_helper(x, y, true); }
int main() {
    bigint a, b;
    cin >> a >> b;
    cout << a / b << '\n';
    return 0;
}

```

## 整数加减乘除
[洛谷P1932 A+B A-B A*B A/B A%B Problem](https://www.luogu.com.cn/problem/P1932)
### Python

```cpp
a, b = int(input()), int(input())
print(a + b, a - b, a * b, a // b, a % b, sep = '\n')
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

struct bigint : deque<int> {
    typedef deque<int> container_type;
    constexpr static int WIDTH = 8, BASE = 1e8;
    bool sign = false;
    // default is null, not zero.
    bigint() {}
    bigint(long long x) {
        if (x < 0) sign = true, x = -x;
        do { push_back(x % BASE); x /= BASE; } while(x);
    }
    bigint(int x) : bigint((long long)x) {}
    bigint(const char *x) {
        if (*x == '-') x++, sign = true;
        char s[WIDTH + 1]{};
        int n = strlen(x), i = n;
        for (; i > WIDTH; i -= WIDTH)
            push_back(atol(strncpy(s, x + i - WIDTH, WIDTH)));
        push_back(atol(strncpy(s + WIDTH - i, x, i)));
    }
    bigint(const string &x) : bigint(x.c_str()) {}
    bigint& operator=(const bigint &x) {
        sign = x.sign;
        assign(x.begin(), x.end());
        return *this;
    }
    bigint operator-() const {
        bigint ans(*this);
        ans.sign = !ans.sign;
        return ans;
    }
    friend bigint operator+(const bigint &x, const bigint &y);
    friend bigint operator-(const bigint &x, const bigint &y);
    friend bigint operator*(const bigint &x, const bigint &y);
    friend bigint operator/(const bigint &x, const bigint &y);
    friend bigint operator%(const bigint &x, const bigint &y);
    bigint& operator+=(const bigint &x) { return *this = *this + x; }
    bigint& operator-=(const bigint &x) { return *this = *this - x; }
    bigint& operator*=(const bigint &x) { return *this = *this * x; }
    bigint& operator/=(const bigint &x) { return *this = *this / x; }
    bigint& operator%=(const bigint &x) { return *this = *this % x; }
    bigint& operator++() { return *this = *this + 1; }
    bigint operator++(int) { bigint ans(*this); *this = *this + 1; return ans; }
    bigint& operator--() { return *this = *this - 1; }
    bigint operator--(int) { bigint ans(*this); *this = *this - 1; return ans; }
    bool operator!() const { return empty() || size() == 1 && back() == 0; }
    operator string() const {
        if (empty()) return "";
        stringstream res;
        if (sign && !!(*this)) res << '-';
        res << back();
        for (int i = size() - 2; i >= 0; i--)
            res << setw(WIDTH) << setfill('0') << at(i);
        return res.str();
    }
};
istream& operator>>(istream &in, bigint &x) {
    string s;
    in >> s;
    x = s;
    return in;
}
ostream& operator<<(ostream &out, const bigint &x) {
    return out << (string)x;
}
bool operator==(const bigint &x, const bigint &y) {
    return !x && !y || x.sign == y.sign && equal_to<bigint::container_type>()(x, y);
}
bool operator<(const bigint &x, const bigint &y) {
    if (!x || !y) return (!!x || !!y) && (!!x && x.sign || !!y && !y.sign);
    if (x.sign != y.sign) return x.sign;
    if (x.size() != y.size()) return x.sign ^ (x.size() < y.size());
    return x.sign ^ lexicographical_compare(x.rbegin(), x.rend(), y.rbegin(), y.rend());
}
bool operator>(const bigint &x, const bigint &y) { return y < x; }
bool operator<=(const bigint &x, const bigint &y) { return !(y < x); }
bool operator>=(const bigint &x, const bigint &y) { return !(x < y); }
bool operator!=(const bigint &x, const bigint &y) { return !(x == y); }
bigint operator+(const bigint &x, const bigint &y) {
    if (x.sign) return y - (-x);
    if (y.sign) return x - (-y);
    bigint ans(x);
    ans.resize(max(x.size(), y.size()) + 1, 0);
    for (int i = 0; i < y.size(); i++) {
        ans[i] += y[i];
        ans[i + 1] += ans[i] / bigint::BASE;
        ans[i] %= bigint::BASE;
    }
    if (ans.back() == 0) ans.pop_back();
    return ans;
}
bigint operator-(const bigint &x, const bigint &y) {
    if (x.sign) return -(-x + y);
    if (y.sign) return x + (-y);
    if (x < y) return -(y - x);
    bigint ans(x);
    for (int i = 0; i < y.size(); i++) {
        if (ans[i] < y[i]) ans[i + 1]--, ans[i] += bigint::BASE;
        ans[i] -= y[i];
    }
    while (ans.size() > 1 && ans.back() == 0) ans.pop_back();
    return ans;
}
bigint operator*(const bigint &x, const bigint &y) {
    if (x == 0 || y == 0) return 0;
    vector<long long> res(x.size() + y.size());
    for (int i = 0; i < x.size(); i++)
        for (int j = 0; j < y.size(); j++)
            res[i + j] += 1ll * x[i] * y[j];
    bigint ans;
    for (int i = 0; i < res.size(); i++) {
        res[i + 1] += res[i] / bigint::BASE;
        ans.push_back(res[i] % bigint::BASE);
    }
    if (ans.back() == 0) ans.pop_back();
    ans.sign = x.sign ^ y.sign;
    return ans;
}
bigint div_helper(const bigint &x, const bigint &y, bool mod = false) {
    assert(y != 0);
    if (x == 0) return 0;
    if (x.sign) return -(-x / y);
    if (y.sign) return -(x / -y);
    bigint q, r;
    for (int i = x.size() - 1; i >= 0; i--) {
        r.push_front(x[i]);
        int lt = 0, rt = bigint::BASE;
        while (lt < rt) {
            int m = (lt + rt + 1) / 2;
            if (y * m <= r) lt = m;
            else rt = m - 1;
        }
        if (lt != 0) q.push_front(lt);
        r = r - y * lt;
    }
    if (q.empty()) q = 0;
    return mod ? r : q;
}
bigint operator/(const bigint &x, const bigint &y) { return div_helper(x, y); }
bigint operator%(const bigint &x, const bigint &y) { return div_helper(x, y, true); }

int main() {
    // freopen("P1932_10.in", "r", stdin);
    // freopen("output.txt", "w", stdout);
    ios::sync_with_stdio(false);cin.tie(0);
    bigint a, b;
    cin >> a >> b;
    cout << a + b << '\n';
    cout << a - b << '\n';
    cout << a * b << '\n';
    cout << a / b << '\n';
    cout << a % b << '\n';
    return 0;
}
```

## 其他

### 奇葩写法
[题解 P1932 【A+B A-B A*B A/B A%B Problem】](https://www.luogu.com.cn/blog/fucknoip/solution-p1932)

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    char a[100000],b[100000],c[100000];
    scanf("%s%s",a,b);
    sprintf(c,"echo %s+%s | bc | tr '\n' ' ' | tr '\\' ' ' | sed 's/ //g'",a,b);
    system(c);
    cout<<endl;
    sprintf(c,"echo %s-%s | bc | tr '\n' ' ' | tr '\\' ' ' | sed 's/ //g'",a,b);
    system(c);
    cout<<endl;
    sprintf(c,"echo %s*%s | bc | tr '\n' ' ' | tr '\\' ' ' | sed 's/ //g'",a,b);
    system(c);
    cout<<endl;
    sprintf(c,"echo %s/%s | bc | tr '\n' ' ' | tr '\\' ' ' | sed 's/ //g'",a,b);
    system(c);
    cout<<endl;
    sprintf(c,"echo %s %% %s | bc | tr '\n' ' ' | tr '\\' ' ' | sed 's/ //g'",a,b);
    system(c);
    cout<<endl;
    return 0;
}
```


## 模板
```cpp
struct bigint : deque<int> {
    typedef deque<int> container_type;
    constexpr static int WIDTH = 8, BASE = 1e8;
    bool sign = false;
    // default is null, not zero.
    bigint() {}
    bigint(long long x) {
        if (x < 0) sign = true, x = -x;
        do { push_back(x % BASE); x /= BASE; } while(x);
    }
    bigint(int x) : bigint((long long)x) {}
    bigint(const char *x) {
        if (*x == '-') x++, sign = true;
        char s[WIDTH + 1]{};
        int n = strlen(x), i = n;
        for (; i > WIDTH; i -= WIDTH)
            push_back(atol(strncpy(s, x + i - WIDTH, WIDTH)));
        push_back(atol(strncpy(s + WIDTH - i, x, i)));
    }
    bigint(const string &x) : bigint(x.c_str()) {}
    bigint& operator=(const bigint &x) {
        sign = x.sign;
        assign(x.begin(), x.end());
        return *this;
    }
    bigint operator-() const {
        bigint ans(*this);
        ans.sign = !ans.sign;
        return ans;
    }
    friend bigint operator+(const bigint &x, const bigint &y);
    friend bigint operator-(const bigint &x, const bigint &y);
    friend bigint operator*(const bigint &x, const bigint &y);
    friend bigint operator/(const bigint &x, const bigint &y);
    friend bigint operator%(const bigint &x, const bigint &y);
    bigint& operator+=(const bigint &x) { return *this = *this + x; }
    bigint& operator-=(const bigint &x) { return *this = *this - x; }
    bigint& operator*=(const bigint &x) { return *this = *this * x; }
    bigint& operator/=(const bigint &x) { return *this = *this / x; }
    bigint& operator%=(const bigint &x) { return *this = *this % x; }
    bigint& operator++() { return *this = *this + 1; }
    bigint operator++(int) { bigint ans(*this); *this = *this + 1; return ans; }
    bigint& operator--() { return *this = *this - 1; }
    bigint operator--(int) { bigint ans(*this); *this = *this - 1; return ans; }
    bool operator!() const { return empty() || size() == 1 && back() == 0; }
    operator string() const {
        if (empty()) return "";
        stringstream res;
        if (sign && !!(*this)) res << '-';
        res << back();
        for (int i = size() - 2; i >= 0; i--)
            res << setw(WIDTH) << setfill('0') << at(i);
        return res.str();
    }
};
istream& operator>>(istream &in, bigint &x) {
    string s;
    in >> s;
    x = s;
    return in;
}
ostream& operator<<(ostream &out, const bigint &x) {
    return out << (string)x;
}
bool operator==(const bigint &x, const bigint &y) {
    return !x && !y || x.sign == y.sign && equal_to<bigint::container_type>()(x, y);
}
bool operator<(const bigint &x, const bigint &y) {
    if (!x || !y) return (!!x || !!y) && (!!x && x.sign || !!y && !y.sign);
    if (x.sign != y.sign) return x.sign;
    if (x.size() != y.size()) return x.sign ^ (x.size() < y.size());
    return x.sign ^ lexicographical_compare(x.rbegin(), x.rend(), y.rbegin(), y.rend());
}
bool operator>(const bigint &x, const bigint &y) { return y < x; }
bool operator<=(const bigint &x, const bigint &y) { return !(y < x); }
bool operator>=(const bigint &x, const bigint &y) { return !(x < y); }
bool operator!=(const bigint &x, const bigint &y) { return !(x == y); }
bigint operator+(const bigint &x, const bigint &y) {
    if (x.sign) return y - (-x);
    if (y.sign) return x - (-y);
    bigint ans(x);
    ans.resize(max(x.size(), y.size()) + 1, 0);
    for (int i = 0; i < y.size(); i++) {
        ans[i] += y[i];
        ans[i + 1] += ans[i] / bigint::BASE;
        ans[i] %= bigint::BASE;
    }
    if (ans.back() == 0) ans.pop_back();
    return ans;
}
bigint operator-(const bigint &x, const bigint &y) {
    if (x.sign) return -(-x + y);
    if (y.sign) return x + (-y);
    if (x < y) return -(y - x);
    bigint ans(x);
    for (int i = 0; i < y.size(); i++) {
        if (ans[i] < y[i]) ans[i + 1]--, ans[i] += bigint::BASE;
        ans[i] -= y[i];
    }
    while (ans.size() > 1 && ans.back() == 0) ans.pop_back();
    return ans;
}
bigint operator*(const bigint &x, const bigint &y) {
    if (x == 0 || y == 0) return 0;
    vector<long long> res(x.size() + y.size());
    for (int i = 0; i < x.size(); i++)
        for (int j = 0; j < y.size(); j++)
            res[i + j] += 1ll * x[i] * y[j];
    bigint ans;
    for (int i = 0; i < res.size(); i++) {
        res[i + 1] += res[i] / bigint::BASE;
        ans.push_back(res[i] % bigint::BASE);
    }
    if (ans.back() == 0) ans.pop_back();
    ans.sign = x.sign ^ y.sign;
    return ans;
}
bigint div_helper(const bigint &x, const bigint &y, bool mod = false) {
    assert(y != 0);
    if (x == 0) return 0;
    if (x.sign) return -(-x / y);
    if (y.sign) return -(x / -y);
    bigint q, r;
    for (int i = x.size() - 1; i >= 0; i--) {
        r.push_front(x[i]);
        while (r.size() > 1 && r.back() == 0) r.pop_back();
        int lt = 0, rt = bigint::BASE;
        while (lt < rt) {
            int m = (lt + rt + 1) / 2;
            if (y * m <= r) lt = m;
            else rt = m - 1;
        }
        if (!q.empty() || lt != 0) q.push_front(lt);
        r = r - y * lt;
    }
    if (q.empty()) q = 0;
    return mod ? r : q;
}
bigint operator/(const bigint &x, const bigint &y) { return div_helper(x, y); }
bigint operator%(const bigint &x, const bigint &y) { return div_helper(x, y, true); }
```


## 高精度非负整数、加法
```cpp
struct BigInteger{
	static const int BASE=100000000;
	static const int WIDTH=8;
	vector<int> s;
	BigInteger(long long num=0){
		*this=num;
	}
	BigInteger(const string &str){
		*this=str;
	}
	BigInteger operator=(long long num){
		s.clear();
		do{
			s.push_back(num%BASE);
			num/=BASE;
		}while(num>0);
		return *this;
	}
	BigInteger operator=(const string &str){
		s.clear();
		int x,len=(str.length()-1)/WIDTH+1;
		for(int i=0;i<len;i++){
			int end=str.length()-i*WIDTH;
			int start=max(0,end-WIDTH);
			sscanf(str.substr(start,end-start).c_str(),"%d",&x);
			s.push_back(x);
		}
		return *this;
	}
	BigInteger operator+(const BigInteger &b)const{
		BigInteger c;
		c.s.clear();
		for(int i=0,g=0;;i++){
			if(g==0&&i>=s.size()&&i>=b.s.size())break;
			int x=g;
			if(i<s.size())x+=s[i];
			if(i<b.s.size())x+=b.s[i];
			c.s.push_back(x%BASE);
			g=x/BASE;
		}
		return c;
	}
	BigInteger operator+=(const BigInteger &b){
		*this=*this+b;
		return *this;
	}
	//注意是否有前导0
	bool operator<(const BigInteger &b)const{
		if(s.size()!=b.s.size())return s.size()<b.s.size();
		for(int i=s.size()-1;i>=0;i--){
			if(s[i]!=b.s[i])return s[i]<b.s[i];
		}
		return false; //相等
	}
	//以下定义具有一般性
	bool operator>(const BigInteger &b)const{
		return b<*this;
	}
	bool operator<=(const BigInteger &b)const{
		return !(b<*this);
	}
	bool operator>=(const BigInteger &b)const{
		return !(*this<b);
	}
	bool operator!=(const BigInteger &b)const{
		return b<*this||*this<b;
	}
	bool operator==(const BigInteger &b)const{
		return !(b<*this)&&!(*this<b);
	}
};
ostream& operator<<(ostream &out,const BigInteger &x){
	out<<x.s.back();
	for(int i=x.s.size()-2;i>=0;i--){
		char buf[20];
		sprintf(buf,"%08d",x.s[i]);
		for(int j=0;j<strlen(buf);j++)out<<buf[j];
	}
	return out;
}
istream& operator>>(istream &in,BigInteger &x){
	string s;
	if(!(in>>s))return in;
	x=s;
	return in;
}
```

## 高精度整数、加减乘除
```cpp

class BigInteger{
private:
	static const int BASE=100000000;
	static const int WIDTH=8;
	bool sign;
	size_t length;
	vector<int> num;

//以下为关键实现代码
private:
	void cutLeadingZero(){
		while(num.back()==0&&num.size()!=1){
			num.pop_back();
		}
	}
	void setLength(){
		cutLeadingZero();
		int tmp=num.back();
		if(tmp==0)length=1;
		else{
			length=(num.size()-1)*WIDTH;
			while(tmp>0){
				length++;
				tmp/=10;
			}
		}
	}
public:
	const BigInteger& operator=(long long n){
		num.clear();
		if(n==0)num.push_back(0);
		if(n>=0)sign=true;
		else if(n==LLONG_MIN){ //注意负数取值范围比正数大1
			*this="-9223372036854775808";
			return *this;
		}else if(n<0){
			sign=false;
			n=-n;
		}
		while(n!=0){
			num.push_back(n%BASE);
			n/=BASE;
		}
		setLength();
		return *this;
	}
	const BigInteger& operator=(const char *n){
		int len=strlen(n),tmp=0,ten=1,stop=0;
		num.clear();
		sign=(n[0]!='-');
		if(!sign)stop=1;
		for(int i=len;i>stop;i--){
			tmp+=(n[i-1]-'0')*ten;
			ten*=10;
			if((len-i)%8==7){
				num.push_back(tmp);
				tmp=0;
				ten=1;
			}
		}
		if((len-stop)%WIDTH!=0){
			num.push_back(tmp);
		}
		setLength();
		return *this;
	}
	friend BigInteger operator+(const BigInteger &a,const BigInteger &b){
		if(!b.sign)return a-(-b);
		if(!a.sign)return b-(-a);
		BigInteger ans;
		int carry=0,aa,bb;
		size_t lena=a.num.size(),lenb=b.num.size();
		size_t len=max(lena,lenb);
		ans.num.clear();
		for(size_t i=0;i<len;i++){
			if(lena<=i)aa=0;
			else aa=a.num[i];
			if(lenb<=i)bb=0;
			else bb=b.num[i];
			ans.num.push_back((aa+bb+carry)%BASE);
			carry=(aa+bb+carry)/BASE;
		}
		if(carry>0)ans.num.push_back(carry);
		ans.setLength();
		return ans;
	}
	friend BigInteger operator-(const BigInteger &a,const BigInteger &b){
		if(!b.sign)return a+(-b);
		if(!a.sign)return -((-a)+b);
		if(a<b)return -(b-a);
		BigInteger ans;
		int carry=0,aa,bb;
		size_t lena=a.num.size(),lenb=b.num.size();
		size_t len=max(lena,lenb);
		ans.num.clear();
		for(size_t i=0;i<len;i++){
			aa=a.num[i];
			if(i>=lenb)bb=0;
			else bb=b.num[i];
			ans.num.push_back((aa-bb-carry+BASE)%BASE);
			if(aa<bb+carry)carry=1;
			else carry=0;
		}
		ans.setLength();
		return ans;
	}
	friend BigInteger operator*(const BigInteger &a,const BigInteger &b){
		size_t lena=a.num.size(),lenb=b.num.size();
		vector<long long> ansLL;
		for(size_t i=0;i<lena;i++){
			for(size_t j=0;j<lenb;j++){
				if(i+j>=ansLL.size())
					ansLL.push_back(1ll*a.num[i]*b.num[j]);
				else
					ansLL[i+j]+=1ll*a.num[i]*b.num[j];
			}
		}
		while(ansLL.back()==0&&ansLL.size()!=1)ansLL.pop_back();
		size_t len=ansLL.size();
		long long carry=0,tmp;
		BigInteger ans;
		ans.sign=(len==1&&ansLL[0]==0)||(a.sign==b.sign);
		ans.num.clear();
		for(size_t i=0;i<len;i++){
			tmp=ansLL[i];
			ans.num.push_back((tmp+carry)%BASE);
			carry=(tmp+carry)/BASE;
		}
		if(carry>0)ans.num.push_back(carry);
		ans.setLength();
		return ans;
	}
	friend BigInteger operator/(const BigInteger &a,const BigInteger &b){
		BigInteger aa(a.abs()),bb(b.abs());
		if(aa<bb)return 0;
		char *str=new char[aa.size()+1];
		memset(str,0,sizeof(char)*(aa.size()+1));
		BigInteger tmp;
		int lena=aa.length,lenb=bb.length;
		for(int i=0;i<=lena-lenb;i++){
			tmp=bb.e(lena-lenb-i);
			while(aa>=tmp){
				++str[i];
				aa=aa-tmp;
			}
			str[i]+='0';
		}
		BigInteger ans(str);
		delete[] str;
		ans.sign=(ans==0||a.sign==b.sign);
		return ans;
	}
	friend bool operator<(const BigInteger &a,const BigInteger &b){
		if(a.sign&&!b.sign)return false;
		else if(!a.sign&&b.sign)return true;
		else if(a.sign&&b.sign){
			if(a.length!=b.length)return a.length<b.length;
			else{
				size_t lena=a.num.size();
				for(int i=lena-1;i>=0;i--){
					if(a.num[i]!=b.num[i])return a.num[i]<b.num[i];
				}
				return false;//equal
			}
		}else return -b<-a;
	}
	friend ostream& operator<<(ostream &out,const BigInteger &n){
		size_t len=n.num.size();
		if(!n.sign)out<<'-';
		out<<n.num.back();
		for(int i=len-2;i>=0;i--)
			out<<setw(WIDTH)<<setfill('0')<<n.num[i];
		return out;
	}
	friend istream& operator>>(istream &in,BigInteger &n){
		string str;
		in>>str;
		size_t len=str.length(),i,start=0;
		if(str[0]=='-')start=1;
		if(str[start]=='\0')return in;
		for(i=start;i<len;i++)
			if(str[i]<'0'||str[i]>'9')return in;
		n=str.c_str();
		return in;
	}
public:
	BigInteger(int n=0){
		*this=n;
	}
	BigInteger(long long n){
		*this=n;
	}
	BigInteger(const char *n){
		*this=n;
	}
	size_t size()const{
		return length;
	}
	const BigInteger& operator=(int n){
		*this=(long long)n;
		return *this;
	}
	BigInteger e(size_t n)const{ // *10^n
		int tmp=n%8;
		BigInteger ans;
		ans.length=n+1;
		n/=8;
		while(ans.num.size()<=n){
			ans.num.push_back(0);
		}
		ans.num[n]=1;
		while(tmp--){
			ans.num[n]*=10;
		}
		return ans*(*this);
	}
	BigInteger abs()const{
		BigInteger ans(*this);
		ans.sign=true;
		return ans;
	}
	const BigInteger& operator+()const{
		return *this;
	}
	BigInteger operator-()const{
		BigInteger ans(*this);
		if(ans!=0)ans.sign=!ans.sign;
		return ans;
	}
	const BigInteger& operator++(){
		*this=*this+1;
		return *this;
	}
	const BigInteger& operator--(){
		*this=*this-1;
		return *this;
	}
	BigInteger operator++(int){
		BigInteger ans(*this);
		*this=*this+1;
		return ans;
	}
	BigInteger operator--(int){
		BigInteger ans(*this);
		*this=*this-1;
		return ans;
	}
	friend BigInteger operator%(const BigInteger &a,const BigInteger &b){
		return a-a/b*b;
	}
	const BigInteger& operator+=(const BigInteger &n){
		*this=*this+n;
		return *this;
	}
	const BigInteger& operator-=(const BigInteger &n){
		*this=*this-n;
		return *this;
	}
	const BigInteger& operator*=(const BigInteger &n){
		*this=*this*n;
		return *this;
	}
	const BigInteger& operator/=(const BigInteger &n){
		*this=*this/n;
		return *this;
	}
	const BigInteger& operator%=(const BigInteger &n){
		*this=*this-*this/n*n;
		return *this;
	}
public:
	bool operator!(){
		return *this==0;
	}
	friend bool operator>(const BigInteger &a,const BigInteger &b){
		return b<a;
	}
	friend bool operator<=(const BigInteger &a,const BigInteger &b){
		return !(b<a);
	}
	friend bool operator>=(const BigInteger &a,const BigInteger &b){
		return !(a<b);
	}
	friend bool operator==(const BigInteger &a,const BigInteger &b){
		return !(a<b)&&!(b<a);
	}
	friend bool operator!=(const BigInteger &a,const BigInteger &b){
		return (a<b)||(b<a);
	}
	friend bool operator||(const BigInteger &a,const BigInteger &b){
		return a!=0||b!=0;
	}
	friend bool operator&&(const BigInteger &a,const BigInteger &b){
		return a!=0&&b!=0;
	}
};

```