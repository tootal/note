# 位运算
# 位运算

## 写在前面

如十进制123，在计算机中存放的是，（0111 1011），一般说右侧为低位，左侧为高位。计算顺序也一般从低位开始。  

## 原码反码补码
参考：
[原码、补码、反码的作用和区别](https://www.cnblogs.com/fangchunying/p/9022783.html)  

计算机中的信息都是以二进制形式表示的，数值有正负之分，计算机就用一个数的最高位存放符号(0为正，1为负)。这就是机器数的原码了。  
对除符号位外的其余各位逐位取反就产生了反码。  
负数的补码就是对反码加一，而正数不变，**正数的原码反码补码是一样的**。  


## 常见位运算操作
请根据情况判断x表示十进制数还是二进制数:smile:  
参考：
[利用异或判断二进制数中的1的个数的奇偶性](https://blog.csdn.net/anlian523/article/details/84488468)  
[位运算骚操作 Part 1](https://www.cnblogs.com/cuancuancuanhao/p/7853098.html)  
[翻转二进制位的一个"奇淫"技巧](https://blog.csdn.net/kwinway/article/details/79325852)  



|           操作           |       代码        |             备注              |
| ------------------------ | ----------------- | ----------------------------- |
| 判断x是否是2的整数次幂    | `!(x&(x-1))`      | 0会判成true                   |
| 计算x二进制中1的个数      | `bitset::count()` | 也可用`__builtin_popcount()`  |
| 找出唯一一个出现奇数次的数 | 全部异或一下       | 偶数次异或为0，异或0不变        |
| 提取x二进制最后一位1       | `x&(-x)`          | 树状数组lowbit                |
| 去掉x最后一位1            | `x&(x-1)`         | 可以用循环来统计1的个数         |
| 计算x中1个数的奇偶性      | log次`x^(x>>n) `  | 异或可以压缩两位上1个数的奇偶性 |
| 交换两个变量x,y           | `x^=y^=x^=y`      | 异或与本身互为逆运算           |
| 位反转x                  | 先两两反转，再。。  | 还是bitset好用                |

## 内置的位运算函数

>  C++ 内置位运算函数 前加 `__builtin_ `前缀  
>  long 以及 long long分别加l和ll后缀  
> 主要有  
>  popcount		统计1的个数  
>  ffs 			计算末尾1位置  
>  clz			统计前导0个数  
>  ctz			统计末尾0个数  
>  parity		统计1个数的奇偶性  

以及STL中的bitset  


## 一些例子
若$n!=k\times 2^m$，求最大的$m$。  

$ans=n-popcount(n)$  
